<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clinic Ad Checker | ‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡∏Ñ‡∏•‡∏¥‡∏ô‡∏¥‡∏Å</title>
  <style>
    body { font-family: Arial, sans-serif; background:#f4f6f8; padding:40px }
    .container { background:#fff; max-width:1100px; margin:auto; padding:30px; border-radius:12px; box-shadow:0 2px 12px rgba(0,0,0,0.08)}
    h1 { margin:0 }
    .muted { color:#6b7280 }
    .danger { color:#dc2626; font-weight:bold }
    .ok { color:#16a34a; font-weight:bold }
    .warn { color:#b45309; font-weight:bold }

    .pill { display:inline-block; padding:4px 10px; border-radius:999px; background:#e5e7eb; font-size:12px; margin-left:8px; font-weight:700 }
    .pill.ok { background: rgba(34,197,94,0.15); color:#166534; }
    .pill.bad { background: rgba(220,38,38,0.12); color:#991b1b; }
    .pill.neutral { background:#e5e7eb; color:#111827; }

    .box { margin-top:18px; padding:16px; border-radius:12px; background:#f9fafb; border:1px solid #eef2f7 }
    ul { margin: 8px 0 0 18px; }
    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .row label { white-space: nowrap; font-weight:700; }
    select { padding:8px 10px; border-radius:10px; border:1px solid #d1d5db; background:#fff }
    button { padding:10px 16px; margin-top:10px; margin-right:10px; cursor:pointer; border-radius:12px; border:none; font-weight:800 }
    .check { background:#2563eb; color:#fff }
    .rewrite { background:#16a34a; color:#fff }
    .ghost { background:#e5e7eb; color:#111827 }
    .statusbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    .small { font-size:12px; }
    .hr { height:1px; background:#eef2f7; margin:12px 0; }
    a { color:#2563eb; text-decoration:none; }
    a:hover { text-decoration:underline; }

    .tag { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; background:#eef2f7; margin-right:6px; }
    .tag.red { background:rgba(220,38,38,0.10); color:#991b1b; }
    .tag.green { background:rgba(34,197,94,0.12); color:#166534; }
    .tag.gray { background:#eef2f7; color:#111827; }

    /* Highlighter overlay */
    .editor-wrap { position: relative; width: 100%; margin-top:12px; }
    .highlighter {
      position: absolute;
      inset: 0;
      padding: 12px;
      font-size: 15px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow: auto;
      border: 1px solid #d1d5db;
      border-radius: 14px;
      background: #fff;
      pointer-events: none;
      color: #111827;
    }
    textarea.editor {
      position: relative;
      width: 100%;
      height: 190px;
      padding: 12px;
      font-size: 15px;
      line-height: 1.6;
      border: 1px solid transparent;
      border-radius: 14px;
      background: transparent;
      color: transparent;
      caret-color: #111827;
      resize: vertical;
      overflow: auto;
      outline: none;
    }
    .hl-ok { background: rgba(34, 197, 94, 0.25); border-radius: 8px; padding: 0 2px; }
    .hl-bad { background: rgba(220, 38, 38, 0.25); border-radius: 8px; padding: 0 2px; }

    #rewriteResult { white-space: pre-wrap; color:#111827; }
    #suggestions { margin-top:10px; }
    .suggestion-box { margin-top:12px; padding:12px; border-radius:12px; background:#fff; border:1px dashed #d1d5db; }
    .suggestion-box h4 { margin:0 0 8px 0; }
  </style>
</head>

<body>
<div class="container">
  <h1>ü©∫ Clinic Ad Checker</h1>
  <div class="muted">‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏≥‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤ + ‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠ (‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Google Sheets CSV)</div>
  <div class="muted small">Version: v7-empty-dash + suggestions</div>

  <div class="box">
    <div class="statusbar">
      <div><b>‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:</b> <span id="loadStatus" class="pill neutral">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‚Ä¶</span></div>
      <div id="keywordCount" class="pill neutral">‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ: 0 | ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: 0</div>
      <div class="pill neutral" id="matchSummary">-</div>
    </div>
    <div class="small muted" style="margin-top:8px">
      ‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: <a id="srcLink" target="_blank" rel="noreferrer">Google Sheets CSV</a>
    </div>
  </div>

  <div class="editor-wrap">
    <div id="highlighter" class="highlighter"></div>
    <textarea id="inputText" class="editor" placeholder="‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡∏Ñ‡∏•‡∏¥‡∏ô‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà..."
      oninput="syncHighlightLive()" onscroll="syncScroll()"></textarea>
  </div>

  <div>
    <button class="check" onclick="checkText()">‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏≥‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤</button>
    <button class="rewrite" onclick="rewriteText()">Rewrite ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ</button>
    <button class="ghost" onclick="clearAll()">‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°</button>
  </div>

  <div class="box">
    <h3>‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à</h3>
    <div id="result">-</div>
    <div id="suggestions"></div>
    <div class="muted small" style="margin-top:8px">‡πÑ‡∏Æ‡πÑ‡∏•‡∏ó‡πå‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß = ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ, ‡∏™‡∏µ‡πÅ‡∏î‡∏á = ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</div>
  </div>

  <div class="box">
    <h3>‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏á Rewrite</h3>
    <div id="rewriteResult" class="muted">-</div>
  </div>

  <div class="box">
    <h3>üìö ‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡∏Ñ‡∏≥‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤ (‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏° Topic)</h3>
    <div class="row">
      <label>‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà:</label>
      <select id="categoryFilter" onchange="onCategoryChange()">
        <option value="all">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
      </select>

      <label>Topic:</label>
      <select id="topicFilter" onchange="renderKeywordLibrary()">
        <option value="all">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
      </select>
    </div>

    <div class="hr"></div>
    <div id="keywordLibrary"></div>
  </div>
</div>

<script>
/***********************
 * ‚úÖ CSV ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì (Publish to web ‡πÅ‡∏•‡πâ‡∏ß)
 ***********************/
const CSV_URL =
  'https://docs.google.com/spreadsheets/d/e/2PACX-1vTYcW7K_bjXlX3ns7Ok_4mbb_45ogxQHwKwyw-2Im9v1iUlS96TPICBy_5t5n973tP3YB1qEB9mQTqc/pub?output=csv';
document.getElementById('srcLink').href = CSV_URL;

/***********************
 * (OPTIONAL) ‡πÄ‡∏û‡∏¥‡πà‡∏° whitelist ‡πÄ‡∏≠‡∏á‡πÑ‡∏î‡πâ
 ***********************/
const EXTRA_WHITELIST_TOKENS = [
  'botox','filler','hifu','meso','ulthera','thermage','rejuran',
  '‡πÇ‡∏ö‡∏ó‡πá‡∏≠‡∏Å','‡πÇ‡∏ö‡∏ó‡∏≠‡∏Å','‡∏ü‡∏¥‡∏•‡πÄ‡∏•‡∏≠‡∏£‡πå','‡πÑ‡∏Æ‡∏ü‡∏π','‡πÄ‡∏°‡πÇ‡∏™','‡∏£‡πâ‡∏≠‡∏¢‡πÑ‡∏´‡∏°','‡πÄ‡∏•‡πÄ‡∏ã‡∏≠‡∏£‡πå','‡∏£‡∏µ‡∏à‡∏π‡∏£‡∏±‡∏ô'
];

/***********************
 * STATE
 ***********************/
const keywordLibraryData = {};
let allowKeywords = [];   // { word, aliases?:[] }
let forbidKeywords = [];  // { word, rewrite, aliases?:[] }
let whitelistTokens = new Set();

/***********************
 * UTILS
 ***********************/
function normalizeText(v) { return String(v ?? '').replace(/\r\n/g, '\n'); }
function normalizeKey(v) { return normalizeText(v).trim().replace(/\s+/g, ' '); }

function escapeHTML(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;').replace(/'/g,'&#039;');
}
function escapeRegExp(s) { return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

function buildFlexibleRegex(keyword) {
  const raw = normalizeText(keyword).trim();
  if (!raw) return null;
  const parts = raw.split(/\s+/).filter(Boolean).map(escapeRegExp);
  return parts.length ? new RegExp(parts.join('\\s+'), 'g') : null;
}

function dedupeByWord(list) {
  const seen = new Set();
  return list.filter(x => {
    const k = normalizeKey(x.word);
    if (!k || seen.has(k)) return false;
    seen.add(k); return true;
  });
}

function setPill(el, type, text) {
  el.classList.remove('ok','bad','neutral');
  el.classList.add(type);
  el.textContent = text;
}

/***********************
 * CSV PARSER
 ***********************/
function parseCSV(text) {
  const s = String(text ?? '').replace(/^\uFEFF/, '');
  const rows = [];
  let row = [];
  let field = '';
  let i = 0;
  let inQuotes = false;

  while (i < s.length) {
    const c = s[i];
    if (inQuotes) {
      if (c === '"') {
        if (s[i + 1] === '"') { field += '"'; i += 2; continue; }
        inQuotes = false; i++; continue;
      }
      field += c; i++; continue;
    } else {
      if (c === '"') { inQuotes = true; i++; continue; }
      if (c === ',') { row.push(field); field = ''; i++; continue; }
      if (c === '\n') { row.push(field); rows.push(row); row = []; field = ''; i++; continue; }
      if (c === '\r') { i++; continue; }
      field += c; i++; continue;
    }
  }
  row.push(field);
  rows.push(row);
  return rows;
}

function findColIndex(headers, candidates) {
  const h = headers.map(x => normalizeKey(x));
  const cands = candidates.map(x => normalizeKey(x)).filter(Boolean);

  for (const c of cands) {
    const idx = h.indexOf(c);
    if (idx >= 0) return idx;
  }
  for (let i = 0; i < h.length; i++) {
    for (const c of cands) {
      if (!c) continue;
      if (h[i].includes(c) || c.includes(h[i])) return i;
    }
  }
  return -1;
}

function parseAliases(raw) {
  const s = normalizeText(raw || '').trim();
  if (!s) return [];
  return s.split(/[\|\n,]+/g).map(x => x.trim()).filter(Boolean);
}

/***********************
 * AUTO-ALIASES
 ***********************/
function generateAutoAliases(word) {
  const w = normalizeText(word || '').trim();
  if (!w) return [];

  const out = new Set();

  const noParen = w.replace(/\s*[\(\Ôºà].*?[\)\Ôºâ]\s*/g, ' ').replace(/\s+/g,' ').trim();
  if (noParen && noParen !== w) out.add(noParen);

  const matches = w.matchAll(/[\(\Ôºà]\s*([^)\Ôºâ]+?)\s*[\)\Ôºâ]/g);
  for (const m of matches) {
    const inside = (m && m[1]) ? m[1].trim() : '';
    if (!inside) continue;
    out.add(inside);
    inside.split(/[\/,|]+/g).map(x=>x.trim()).filter(Boolean).forEach(x => out.add(x));
  }

  const patterns = [/‡∏ã‡πå\s*$/u, /‡∏™‡πå\s*$/u, /‡∏ï‡πå\s*$/u, /‡∏î‡πå\s*$/u, /‡∏©‡πå\s*$/u, /‡∏£‡πå\s*$/u, /‡∏•‡πå\s*$/u, /‡∏ô‡πå\s*$/u, /‡πå\s*$/u];
  for (const p of patterns) {
    if (p.test(w)) {
      const a = w.replace(p, '').trim();
      if (a.length >= 2) out.add(a);
    }
    if (p.test(noParen)) {
      const a2 = noParen.replace(p, '').trim();
      if (a2.length >= 2) out.add(a2);
    }
  }

  const addCase = (s) => {
    if (!s) return;
    if (/[a-zA-Z]/.test(s)) { out.add(s.toLowerCase()); out.add(s.toUpperCase()); }
  };
  addCase(w); addCase(noParen);
  for (const x of Array.from(out)) addCase(x);

  out.add(w.replace(/\s+/g,''));
  out.add(noParen.replace(/\s+/g,''));

  out.delete(w);
  return Array.from(out).map(x=>x.trim()).filter(x => x && x.length >= 2);
}

/***********************
 * WHITELIST / FUZZY
 ***********************/
function normalizeThaiLite(s) {
  return String(s || '')
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/[^\u0E00-\u0E7Fa-z0-9]/g,'')
    .replace(/[‡πà‡πâ‡πä‡πã]/g, '')
    .replace(/[‡πå]/g, '')
    .replace(/‡πÜ/g, '')
    .trim();
}

function levenshtein(a, b) {
  a = a || ''; b = b || '';
  const m = a.length, n = b.length;
  if (m === 0) return n;
  if (n === 0) return m;
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
    }
  }
  return dp[m][n];
}

function tokenizeUserText(raw) {
  return String(raw || '')
    .split(/[\s,.;:!?()\[\]{}"‚Äú‚Äù'‚Äò‚Äô\-_/\\|]+/g)
    .map(x => x.trim())
    .filter(Boolean);
}

function fuzzyThreshold(len) {
  if (len <= 4) return 0;
  if (len <= 7) return 1;
  return 2;
}

function rebuildWhitelistTokens() {
  const set = new Set();

  for (const k of forbidKeywords) {
    const w = normalizeThaiLite(k.word);
    if (w && w.length >= 3) set.add(w);
    if (Array.isArray(k.aliases)) {
      for (const a of k.aliases) {
        const an = normalizeThaiLite(a);
        if (an && an.length >= 3) set.add(an);
      }
    }
  }
  for (const t of EXTRA_WHITELIST_TOKENS) {
    const tn = normalizeThaiLite(t);
    if (tn && tn.length >= 3) set.add(tn);
  }
  whitelistTokens = set;
}

function isWhitelistedToken(token) {
  const tN = normalizeThaiLite(token);
  if (!tN) return false;
  if (whitelistTokens.has(tN)) return true;
  if (tN.length < 4) return false;
  for (const w of whitelistTokens) {
    if (w.length < 4) continue;
    if (tN.includes(w) || w.includes(tN)) return true;
  }
  return false;
}

function buildLooseThaiRegex(keyword) {
  const raw = String(keyword || '').trim();
  if (!raw) return null;
  const cleaned = raw.replace(/\s+/g, '').replace(/[^\u0E00-\u0E7Fa-zA-Z0-9]/g, '');
  if (!cleaned) return null;
  const THAI_MARKS = '[\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E]*';
  const parts = [];
  for (const ch of cleaned) parts.push(`${escapeRegExp(ch)}${THAI_MARKS}`);
  const pattern = parts.join('\\s*');
  return new RegExp(pattern, 'gi');
}

function extractWhitelistSubtokens(text) {
  const tN = normalizeThaiLite(text);
  const out = [];
  if (!tN) return out;
  for (const w of whitelistTokens) {
    if (w.length < 4) continue;
    if (tN.includes(w)) out.push(w);
  }
  return out;
}

function fuzzyHitKeywordWhitelisted(userText, keyword) {
  const kwN = normalizeThaiLite(keyword);
  if (!kwN || kwN.length < 3) return { hit:false };

  const tokens = tokenizeUserText(userText);
  const extra = extractWhitelistSubtokens(userText);
  const allTokens = tokens.concat(extra);

  const th = fuzzyThreshold(kwN.length);

  for (const t of allTokens) {
    if (!isWhitelistedToken(t)) continue;
    const tN = normalizeThaiLite(t);
    if (!tN) continue;

    if (tN.includes(kwN) || kwN.includes(tN)) return { hit:true, sample:t, dist:0 };

    if (Math.abs(tN.length - kwN.length) > 2) continue;
    const d = levenshtein(tN, kwN);
    if (d <= th) return { hit:true, sample:t, dist:d };
  }
  return { hit:false };
}

/***********************
 * HIGHLIGHT
 ***********************/
function syncScroll() {
  const ta = document.getElementById('inputText');
  const hl = document.getElementById('highlighter');
  hl.scrollTop = ta.scrollTop;
  hl.scrollLeft = ta.scrollLeft;
}

function mergeSpans(spans) {
  if (!spans.length) return [];
  spans.sort((a,b) => a.start - b.start || (b.end-b.start)-(a.end-a.start));
  const merged = [];
  for (const s of spans) {
    if (!merged.length) { merged.push({...s}); continue; }
    const last = merged[merged.length-1];
    if (s.start >= last.end) { merged.push({...s}); continue; }
    if (last.type === 'bad') last.end = Math.max(last.end, s.end);
    else if (s.type === 'bad') {
      if (s.start > last.start) { last.end = s.start; merged.push({...s}); }
      else merged[merged.length-1] = {...s};
    } else last.end = Math.max(last.end, s.end);
  }
  return merged;
}

function renderHighlightWithSpans(text, spans) {
  const original = normalizeText(text);
  if (!original) return '';
  if (!spans || !spans.length) return escapeHTML(original);
  const merged = mergeSpans(spans);
  let out = '';
  let cursor = 0;
  for (const s of merged) {
    if (s.start > cursor) out += escapeHTML(original.slice(cursor, s.start));
    const chunk = escapeHTML(original.slice(s.start, s.end));
    out += `<span class="${s.type === 'bad' ? 'hl-bad' : 'hl-ok'}">${chunk}</span>`;
    cursor = s.end;
  }
  if (cursor < original.length) out += escapeHTML(original.slice(cursor));
  return out;
}

function buildHighlights(text) {
  const original = normalizeText(text);
  if (!original) return '';
  const spans = [];
  const pushMatches = (list, type) => {
    for (const k of list) {
      const candidates = [k.word].concat(Array.isArray(k.aliases) ? k.aliases : []);
      for (const c of candidates) {
        const rx = buildFlexibleRegex(c);
        if (!rx) continue;
        let m;
        while ((m = rx.exec(original)) !== null) {
          if (!m[0]) { rx.lastIndex++; continue; }
          spans.push({ start: m.index, end: m.index + m[0].length, type });
        }
      }
    }
  };
  pushMatches(allowKeywords, 'ok');
  pushMatches(forbidKeywords, 'bad');
  return renderHighlightWithSpans(original, spans);
}

function syncHighlightLive() {
  const ta = document.getElementById('inputText');
  document.getElementById('highlighter').innerHTML = buildHighlights(ta.value);
  syncScroll();
}

/***********************
 * ‚úÖ Suggestions helper
 ***********************/
function uniq(arr) {
  const s = new Set();
  const out = [];
  for (const x of arr) {
    const k = normalizeKey(x);
    if (!k || s.has(k)) continue;
    s.add(k); out.push(x);
  }
  return out;
}

function getReplacement(item) {
  // ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô "-"
  const r = normalizeText(item.rewrite || '').trim();
  return r ? r : '-';
}

function renderSuggestionsFromBad(badItems) {
  const box = document.getElementById('suggestions');

  const reps = uniq(
    badItems
      .map(it => getReplacement(it))
      .filter(x => normalizeKey(x) && normalizeKey(x) !== '-')
  );

  if (!badItems.length) {
    box.innerHTML = '';
    return;
  }

  if (!reps.length) {
    box.innerHTML = `
      <div class="suggestion-box">
        <h4>üí° ‡∏Ç‡πâ‡∏≠‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ / ‡∏Ñ‡∏≥‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</h4>
        <div class="muted">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (-)</div>
      </div>
    `;
    return;
  }

  box.innerHTML = `
    <div class="suggestion-box">
      <h4>üí° ‡∏Ç‡πâ‡∏≠‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ / ‡∏Ñ‡∏≥‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</h4>
      <div>${reps.map(x => `<span class="tag green">${escapeHTML(x)}</span>`).join(' ')}</div>
    </div>
  `;
}

/***********************
 * CHECK
 ***********************/
function checkText() {
  const text = normalizeText(document.getElementById('inputText').value || '');
  const resultDiv = document.getElementById('result');
  const summary = document.getElementById('matchSummary');

  if (!allowKeywords.length && !forbidKeywords.length) {
    resultDiv.innerHTML = '<span class="muted">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏≥</span>';
    summary.textContent = '-';
    document.getElementById('suggestions').innerHTML = '';
    syncHighlightLive();
    return;
  }

  const foundOk = [];
  const foundBadExact = [];
  const foundBadLoose = [];
  const foundBadFuzzy = [];

  const scanExact = (list, sink) => {
    for (const k of list) {
      const candidates = [k.word].concat(Array.isArray(k.aliases) ? k.aliases : []);
      for (const c of candidates) {
        const rx = buildFlexibleRegex(c);
        if (!rx) continue;
        if (rx.test(text)) { sink.push(k); break; }
      }
    }
  };

  scanExact(forbidKeywords, foundBadExact);
  scanExact(allowKeywords, foundOk);

  const exactSet = new Set(foundBadExact.map(x => normalizeKey(x.word)));

  for (const k of forbidKeywords) {
    if (exactSet.has(normalizeKey(k.word))) continue;
    const candidates = [k.word].concat(Array.isArray(k.aliases) ? k.aliases : []);
    let hitLoose = false;
    for (const c of candidates) {
      const loose = buildLooseThaiRegex(c);
      if (loose && loose.test(text)) { hitLoose = true; break; }
    }
    if (hitLoose) foundBadLoose.push(k);
  }

  const looseSet = new Set(foundBadLoose.map(x => normalizeKey(x.word)));

  for (const k of forbidKeywords) {
    const key = normalizeKey(k.word);
    if (exactSet.has(key) || looseSet.has(key)) continue;

    let hit = fuzzyHitKeywordWhitelisted(text, k.word);
    if (!hit.hit && Array.isArray(k.aliases)) {
      for (const a of k.aliases) {
        hit = fuzzyHitKeywordWhitelisted(text, a);
        if (hit.hit) break;
      }
    }
    if (hit.hit) foundBadFuzzy.push(k);
  }

  const okU = dedupeByWord(foundOk);
  const badExactU = dedupeByWord(foundBadExact);
  const badExtraU = dedupeByWord(foundBadLoose.concat(foundBadFuzzy));
  const badAll = dedupeByWord(badExactU.concat(badExtraU));

  const badTotal = badAll.length;
  summary.textContent = `‡∏û‡∏ö: ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ${badTotal} | ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ ${okU.length}`;

  if (!okU.length && badTotal === 0) {
    resultDiv.innerHTML = '<span class="warn">‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏≠‡∏≤‡∏à‡∏™‡∏∞‡∏Å‡∏î‡∏ï‡πà‡∏≤‡∏á/‡∏Ñ‡∏≥‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á)</span>';
    document.getElementById('suggestions').innerHTML = '';
    syncHighlightLive();
    return;
  }

  let html = '';
  if (badAll.length) {
    html += `<div class="danger">‚úò ‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ/‡∏ô‡πà‡∏≤‡∏™‡∏á‡∏™‡∏±‡∏¢ (${badAll.length})</div>`;
    html += '<ul>' + badAll.map(x => `<li><span class="danger">${escapeHTML(x.word)}</span></li>`).join('') + '</ul>';
  }
  if (okU.length) {
    html += `<div class="ok" style="margin-top:10px">‚úî ‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ (${okU.length})</div>`;
    html += '<ul>' + okU.map(x => `<li><span class="ok">${escapeHTML(x.word)}</span></li>`).join('') + '</ul>';
  }

  resultDiv.innerHTML = html;
  renderSuggestionsFromBad(badAll);
  syncHighlightLive();
}

/***********************
 * REWRITE
 ***********************/
function cleanupText(t) {
  return String(t || '')
    .replace(/[ \t]+\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')
    .replace(/[ \t]{2,}/g, ' ')
    .trim();
}

function rewriteText() {
  let text = normalizeText(document.getElementById('inputText').value || '');
  if (!text.trim()) {
    document.getElementById('rewriteResult').innerText = '-';
    return;
  }

  if (!forbidKeywords.length) {
    document.getElementById('rewriteResult').innerText = cleanupText(text);
    return;
  }

  const sorted = forbidKeywords
    .filter(k => k.word)
    .slice()
    .sort((a, b) => (b.word.length - a.word.length));

  // 1) exact + alias
  for (const item of sorted) {
    const replacement = getReplacement(item); // ‚úÖ ‡∏ß‡πà‡∏≤‡∏á = "-"
    const candidates = [item.word].concat(Array.isArray(item.aliases) ? item.aliases : []);
    for (const c of candidates) {
      const rx = buildFlexibleRegex(c);
      if (!rx) continue;
      text = text.replace(rx, replacement);
    }
  }

  // 2) loose Thai
  for (const item of sorted) {
    const replacement = getReplacement(item);
    const candidates = [item.word].concat(Array.isArray(item.aliases) ? item.aliases : []);
    for (const c of candidates) {
      const loose = buildLooseThaiRegex(c);
      if (!loose) continue;
      text = text.replace(loose, replacement);
    }
  }

  text = cleanupText(text);

  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏ó‡πâ‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ö‡∏ö‡∏™‡∏±‡πâ‡∏ô (‡πÑ‡∏°‡πà‡∏£‡∏Å)
  const recommended = uniq(sorted.map(it => getReplacement(it)).filter(x => normalizeKey(x) && normalizeKey(x) !== '-'));
  if (recommended.length) {
    text += `\n\n‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥/‡∏Ñ‡∏≥‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ${recommended.join(', ')}`;
  } else {
    text += `\n\n‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥/‡∏Ñ‡∏≥‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: -`;
  }

  text += '\n\n*‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏ñ‡πâ‡∏≠‡∏¢‡∏Ñ‡∏≥‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏¢‡πÉ‡∏ô (Google Sheets) ‡∏ó‡∏µ‡πà‡∏ù‡πà‡∏≤‡∏¢ Marketing ‡∏î‡∏π‡πÅ‡∏•';
  text += '\n*‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏• ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡πÇ‡∏î‡∏¢‡πÅ‡∏û‡∏ó‡∏¢‡πå';

  document.getElementById('rewriteResult').innerText = text;
}

function clearAll() {
  document.getElementById('inputText').value = '';
  document.getElementById('result').innerHTML = '-';
  document.getElementById('rewriteResult').innerText = '-';
  document.getElementById('matchSummary').textContent = '-';
  document.getElementById('suggestions').innerHTML = '';
  syncHighlightLive();
}

/***********************
 * GUIDE
 ***********************/
function rebuildCategoryFilter() {
  const select = document.getElementById('categoryFilter');
  select.innerHTML = '<option value="all">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>';
  Object.keys(keywordLibraryData)
    .sort((a,b) => a.localeCompare(b,'th'))
    .forEach(cat => {
      const opt = document.createElement('option');
      opt.value = cat;
      opt.textContent = cat;
      select.appendChild(opt);
    });
}

function rebuildTopicFilter() {
  const cat = document.getElementById('categoryFilter').value;
  const topicSelect = document.getElementById('topicFilter');
  topicSelect.innerHTML = '<option value="all">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>';

  const set = new Set();
  if (cat === 'all') {
    Object.keys(keywordLibraryData).forEach(c => Object.keys(keywordLibraryData[c] || {}).forEach(t => set.add(t)));
  } else {
    Object.keys(keywordLibraryData[cat] || {}).forEach(t => set.add(t));
  }
  Array.from(set).sort((a,b)=>a.localeCompare(b,'th')).forEach(t => {
    const opt = document.createElement('option');
    opt.value = t;
    opt.textContent = t;
    topicSelect.appendChild(opt);
  });
}

function onCategoryChange() {
  rebuildTopicFilter();
  renderKeywordLibrary();
}

function renderKeywordLibrary() {
  const category = document.getElementById('categoryFilter').value;
  const topic = document.getElementById('topicFilter').value;
  const container = document.getElementById('keywordLibrary');
  const sortNum = (a,b) => (a.no ?? 1e15) - (b.no ?? 1e15);

  let html = '';
  const cats = (category === 'all') ? Object.keys(keywordLibraryData) : [category];

  cats.filter(c => !!keywordLibraryData[c])
    .sort((a,b)=>a.localeCompare(b,'th'))
    .forEach(cat => {
      const topicsObj = keywordLibraryData[cat];
      const topicKeys = Object.keys(topicsObj).filter(tk => topic === 'all' ? true : tk === topic);
      if (!topicKeys.length) return;

      html += `<div style="margin-bottom:22px"><h3>üìå ${escapeHTML(cat)}</h3>`;

      for (const tk of topicKeys) {
        const t = topicsObj[tk];
        const allow = (t.allowItems||[]).slice().sort(sortNum);
        const forbid = (t.forbidItems||[]).slice().sort(sortNum);

        html += `<div style="margin-left:12px;margin-bottom:14px"><h4>${escapeHTML(t.topic)}</h4>`;
        let n = 1;
        for (const it of allow) { html += `<div>${n}. <span class="ok">‚úî ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ</span>: ${escapeHTML(it.keyword)}</div>`; n++; }
        for (const it of forbid) {
          const rep = normalizeText(it.rewrite || '').trim() || '-';
          html += `<div>${n}. <span class="danger">‚úò ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</span>: ${escapeHTML(it.keyword)} <span class="muted small">(‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ${escapeHTML(rep)})</span></div>`;
          n++;
        }
        html += `</div>`;
      }
      html += `</div>`;
    });

  container.innerHTML = html || '<i class="muted">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</i>';
}

/***********************
 * LOAD (CSV)
 ***********************/
async function loadFromGoogleSheets() {
  const statusEl = document.getElementById('loadStatus');

  try {
    setPill(statusEl, 'neutral', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‚Ä¶');

    const res = await fetch(CSV_URL, { cache: 'no-store' });
    const raw = await res.text();
    if (raw.trim().startsWith('<')) throw new Error('Google returned HTML');

    const table = parseCSV(raw);
    if (!table.length) throw new Error('Empty CSV');

    const headers = table[0] || [];

    const idxCategory = findColIndex(headers, ['Category', '‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà']);
    const idxTopic    = findColIndex(headers, ['TOPIC', 'Topic', '‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠']);
    const idxNo       = findColIndex(headers, ['No.', 'No', '‡∏•‡∏≥‡∏î‡∏±‡∏ö', '#']);
    const idxKeyword  = findColIndex(headers, ['Keyword', '‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à', '‡∏Ñ‡∏≥']);
    const idxStatus   = findColIndex(headers, ['Status', '‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞']);
    const idxRewrite  = findColIndex(headers, ['‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡πÑ‡∏î‡πâ', 'Rewrite', '‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥', '‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô', '‡∏Ñ‡∏≥‡πÅ‡∏ó‡∏ô']);
    const idxAliases  = findColIndex(headers, ['Aliases', 'Alias', '‡∏Ñ‡∏≥‡∏û‡πâ‡∏≠‡∏á', '‡∏Ñ‡∏≥‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏≠‡∏∑‡πà‡∏ô', '‡∏Ñ‡∏≥‡∏™‡∏∞‡∏Å‡∏î‡∏≠‡∏∑‡πà‡∏ô']);

    allowKeywords = [];
    forbidKeywords = [];
    Object.keys(keywordLibraryData).forEach(k => delete keywordLibraryData[k]);

    const rows = table.slice(1);

    for (const r of rows) {
      const cells = r.map(x => normalizeText(x));

      const categoryRaw = cells[idxCategory] ?? cells[0] ?? '';
      const topicRaw    = cells[idxTopic]    ?? cells[1] ?? '';
      const noRaw       = cells[idxNo]       ?? cells[2] ?? '';
      const keywordRaw  = cells[idxKeyword]  ?? cells[3] ?? '';
      const statusRaw   = cells[idxStatus]   ?? cells[4] ?? '';
      const rewriteRaw  = (idxRewrite >= 0) ? (cells[idxRewrite] ?? '') : (cells[5] ?? '');
      const aliasesRaw  = (idxAliases >= 0) ? (cells[idxAliases] ?? '') : '';

      const keyword = normalizeText(keywordRaw).trim();
      if (!keyword) continue;

      const s = normalizeKey(statusRaw);
      const isForbid = s.includes('‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ') || s.includes('‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏ä‡πâ') || s.includes('‡∏´‡πâ‡∏≤‡∏°');
      const isAllow  = !isForbid && (s.includes('‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ') || s.includes('‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï') || s.includes('‡∏ú‡πà‡∏≤‡∏ô'));
      if (!isAllow && !isForbid) continue;

      const category = normalizeKey(categoryRaw) || '(‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà)';
      const topic = normalizeKey(topicRaw) || '(‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏ Topic)';
      const parsedNo = Number.isFinite(Number(noRaw)) ? Number(noRaw) : NaN;

      const manualAliases = parseAliases(aliasesRaw);
      const autoAliases = generateAutoAliases(keyword);
      const aliases = Array.from(new Set([].concat(manualAliases, autoAliases).filter(Boolean)));

      const rewrite = normalizeText(rewriteRaw).trim(); // ‡∏≠‡∏≤‡∏à‡∏ß‡πà‡∏≤‡∏á

      if (isAllow) allowKeywords.push({ word: keyword, aliases });
      if (isForbid) forbidKeywords.push({ word: keyword, rewrite, aliases });

      if (!keywordLibraryData[category]) keywordLibraryData[category] = {};
      if (!keywordLibraryData[category][topic]) {
        keywordLibraryData[category][topic] = { topic, allowItems: [], forbidItems: [] };
      }
      if (isAllow) keywordLibraryData[category][topic].allowItems.push({ no: parsedNo, keyword });
      if (isForbid) keywordLibraryData[category][topic].forbidItems.push({ no: parsedNo, keyword, rewrite });
    }

    allowKeywords = dedupeByWord(allowKeywords);
    forbidKeywords = dedupeByWord(forbidKeywords);
    rebuildWhitelistTokens();

    document.getElementById('keywordCount').textContent =
      `‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ: ${allowKeywords.length} | ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: ${forbidKeywords.length}`;

    rebuildCategoryFilter();
    rebuildTopicFilter();
    renderKeywordLibrary();
    syncHighlightLive();

    setPill(statusEl, 'ok', '‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
  } catch (e) {
    console.error(e);
    setPill(statusEl, 'bad', '‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    document.getElementById('keywordLibrary').innerHTML =
      `<div class="danger">‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à</div>`;
  }
}

/***********************
 * INIT
 ***********************/
loadFromGoogleSheets();
</script>
</body>
</html>
